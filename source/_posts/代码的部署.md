---
title: 代码的部署
date: 2018-06-21 10:04:55
categories: 框架
---



# 前言


这是对代码部署部分的思考

<!--more--><!--more-->



# 历史


1. html和css丢服务器，浏览器请求，返回200即可。

2. 但访问需要时间，希望浏览器缓存，返回304。

3. 但304是协商缓存，同样要和服务器请求一次，需要抹去这个请求，变成from cache.强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信.

4. 这样存在一个问题，就是不和服务器通信了，如何更新？    方法就是在后面加上版本号？v=1.00


5. 但引用多个文件只更新一个怎么办？要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。  联想到利用 数据摘要算法 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息
6. 现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径；
7. 当静态资源和动态的资源同时更新的时候，先上线页面，还是先上线静态资源？

 - 先部署页面，再部署资源：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。
	layer的样式更新，但是浏览器还是缓存的老样式，在缓存过期前一直都是错误样式
	


 - 先部署资源，再部署页面：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。
   页面没有改变，但用的最新的layer杨思，页面部署完成后，样式更新

8.解决它也好办，就是实现非覆盖式发布。用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。


总结下来就是：


- 配置超长时间的本地缓存 —— 节省带宽，提高性能
- 采用内容摘要作为缓存更新依据 —— 精确的缓存控制
- 静态资源CDN部署 —— 优化网络请求
- 更资源发布路径实现非覆盖式发布 —— 平滑升级
  


# 前后分离

前端后端协作方式：服务器端渲染+做前后端分离



- 服务器端渲染：（Html网页的内容是在服务器端生成）

是指在服务器端就将网页直接生成，浏览器这里拿到的是一整个网页，CSS和JS的部分是在浏览器端执行的，而网页的内容部分，也就是数据，是由服务器端生成的。 


- 前后端分离

浏览器端先拿到Html，然后和后端通过Ajax接口获取，或者是通过其他接口获取。根据数据渲染html。


浏览器和服务端传递的是数据，而在服务器端渲染的过程中，传递的是Html网页。


## 性能的差距

1. 数据量

前后端分离中传递数据，所以传输量会小。

服务器端渲染，会传输更大的数据，而且会有很多是重复内容。

2. 体验

前后端多了一个渲染数据的过程，需要考虑首屏渲染的问题

服务器端省去了这个过程。

3. 解耦

前后端分离中，传输的是数据，Model，数据怎么展示，全部交给前端来处理，后端只负责提供数据。

服务器端渲染中，传输的是Html，后端传给前端的Model，通常是直接用模板技术生成（JSP，Velocity，freemak）等。 （这种情况会导致html的页面中会有后端代码）

4. 路由控制

在前后端分离中，跳转的页面控制，全部是由前端来决定。跟后端完全没有关系。

在服务器端渲染的方式中，大部分是由后端来决定，少部分是由前端来决定。

5. SEO

前后端分离的方式，通常的载体是SPA（单页面开发），所以拿到的是没有数据的空壳子，很多搜索引擎，不支持SPA方式的SEO。

服务器端渲染的方式，因为生成的是网页，所以对SEO支持的很好。


考虑前后分离的情况:

首先要思考页面是否需要支持SEO，官网和门户网这种需要搜索引擎优化。这种就必须使用服务器端渲染。否则损失惨重。





